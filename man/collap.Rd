% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/collap.R
\name{collap}
\alias{collap}
\title{Aggregation of multi-type and multi-level data}
\usage{
collap(X, by = NULL, FUN = mean, catFUN = Mode,
  factors = "as.categorical", custom = NULL, custom.names = TRUE,
  collapse = TRUE, sort = TRUE, reshape.long = FALSE, na.rm = TRUE,
  replace.nan = TRUE, as.list = FALSE, dropcat = FALSE,
  dropby = FALSE, show.statistic = TRUE, data.table = FALSE,
  parallel = FALSE, ...)
}
\arguments{
\item{X}{A vector, matrix, list, data.frame or data.table to aggregate (anything that can be coerced to data.frame)}

\item{by}{Columns to aggregate by, \bold{either contained in X} and indicated using a one-or two sided formula (two-sided if only certain columns in X are to be aggregated), column indices, a vector of column names, or a string of comma-separated column names, \bold{or externally supplied} in form of a vector, list of vectors or data.frame, with the number of elements/rows matching that of X. If 'by' is left empty, columns are fully aggregated.}

\item{FUN}{Function(s) to apply to numeric columns in X, defaults to the mean. A single function can be supplied without quotes. Multiple functions can be supplied as a character vector, string of comma-separated function names, or as a list of functions (preferably named). Ad-hoc functions can be supplied.}

\item{catFUN}{Function(s) to apply to categorical columns in X, defaults to the Mode. If all elements in a group defined by 'by' are distinct, the Mode defaults to the first element. Multiple functions can be supplied in the same manor as to 'FUN'.}

\item{factors}{Specifies treatment of factor variables. Default is treatment as categorical variables. Alternatively factors can be coerced to numerical variables by spcifying "as.numeric", or the factor levels can be extracted and coerced to a numerical variable by specifying "as.numeric.fractor" (internally defined as:
\code{as.numeric.factor <- function(x) \{as.numeric(levels(x))[x]\})}}

\item{custom}{Option to supply a custom vector or list of functions whose length must match the number of columns to be aggregated. Alternatively a named list can be provided with the names being the comma-separated names of the columns to be aggregated by different functions, i.e. list("var1,var2,var3" = mean, var4 = median, "var7,var8" = sd).}

\item{custom.names}{Interact the column names with the respective function names in 'custom'.}

\item{collapse}{If collapse = FALSE, the aggregated data will be matched with the original data in the 'by' argument and \emph{collap} will return a dataset that is aggregated but of the same dimensions and row-order as the original data, i.e. a between-transformed dataset.}

\item{sort}{Sort restores the columns back to their original order after aggregation. If sort = FALSE, the dataset is returned with the 'by' columns in front, and the other columns following in the order of computation (first numeric columns and then categorical columns, or columns in the order they are passed to 'custom').}

\item{reshape.long}{If multiple functions are supplied to either 'FUN' or 'catFUN', by default \emph{collap} returns a wider dataset. If reshape.long = TRUE, then a long form of the dataset is returned with an additional column 'Statistic' indicating the function used for aggregation.}

\item{na.rm}{Removes missing values from all columns before applying any functions. This is done internally in \emph{collap}, thus it is not required for functions in 'FUN' or 'catFUN' to have a 'na.rm' argument.}

\item{replace.nan}{Replaces NaN values with NA values. NaN's are frequently generated if na.rm = TRUE, and aggregation takes place over an empty subset.}

\item{as.list}{Optionally the output can be requested as a list of vectors or data.frames. There are two options here: If as.list = "by", then a list will be returned whose elements are the aggregated output for each group in 'by'. If multiple functions are supplied to either 'FUN' or 'catFUN', calling as.list = "FUN" will return a list with the dataset aggregated by the different functions. as.list = "by" may come at some slight extra computational cost but as.list = "FUN" does not.}

\item{dropcat}{Drop all categorical variables apart from identifiers in 'by' (i.e. don't perform aggregation on them).}

\item{dropby}{Drop the columns in 'by' from the final output.}

\item{show.statistic}{If multiple functions are called and reshape.long = TRUE, show.statistic = FALSE can be called to omit the 'Statistic' column and instead make appropriate row.names.}

\item{data.table}{By default \emph{collap} is built as a wrapper around \emph{aggregate.data.frame}. Calling this argument will internally use \emph{data.table} as workhorse function, yielding significant speed improvements for large datasets. Requires \code{data.table} package to be installed.}

\item{parallel}{If multiple functions are supplied to 'FUN' or 'catFUN', parallel = TRUE will automatically parallelize computation on $k-1$ of the available cores (using the \emph{parLapply} function from the \emph{parallel} package). The argument works together with data.table = TRUE to guarantee maximum performance on tasks involving large datsets and multiple functions.}

\item{...}{Additional arguments supplied to 'FUN', 'catFUN' or to \emph{aggregate.data.frame} in the default mode.}
}
\description{
The function \code{collap} allows you to aggregate datasets with
multiple types (numeric, factor) in a single function call.
}
